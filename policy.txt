# -*- mode: org; -*-

* Goals
** Ensure integrity of the kernel

** Ensure integrity of the OS runtime

- Logs
- Time
- Static OS components

** Protect hosted and user data

- /home
- /srv
- /var/lib/<service>

Must be protected even from rogue root process.

** Store privacy

- Strong Store privacy: process should be restricted to the subset
  of the Store required for normal operation, as determined by the
  administrator.  Too difficult.
- Weak Store privacy: processes should only be permitted access to store
  paths they already know about.  This leaves open the possibility of
  leaking secrets (the adversary simply designs an expression that takes
  the paths they want to read as inputs and tricks the user into
  realizing & executing the output), but this requires more effort than
  merely enumerating the contents of the local store.
- Usability: Users must be able to read any store path referenced under
  /run/current-system/sw
- Usability: Users must be able to read any store path referenced by their
  own user profile

* Non-goals
** Least privilege

A true least privilege policy is attainable only on a per host basis,
only after extensive full system learning, and even then is going to be
difficult to "get right" on dynamic configurations.

* Policy notes
** Problematic capabilities

*** CAP_KILL

*** CAP_LINUX_IMMUTABLE

*** CAP_MKNOD

*** CAP_NET_ADMIN

*** CAP_NET_BIND_SERVICE

*** CAP_NET_RAW

*** CAP_SETFCAP

*** CAP_SETPCAP

*** CAP_SYSLOG

*** CAP_SYS_ADMIN

*** CAP_SYS_BOOT

*** CAP_SYS_MODULE

*** CAP_SYS_PTRACE

*** CAP_SYS_RAWIO

*** CAP_SYS_TIME

*** CAP_SYS_TTY_CONFIG

** Problematic paths

*** /dev/kmsg

kernel ring buffer
may contain sensitive information
must be tamper proof

*** /dev/mem

raw access to memory

*** /dev/port

raw access to I/O ports

*** /proc/modules

currently loaded modules (leaks kernel pointers)

*** /proc/kallsyms

*** /proc/bus

bus specific information

*** /proc/iomem

memory map

*** /proc/kcore

image of physical memory

* Abstractions
** base

/dev/urandom r

/dev/null rw
/dev/zero rw
/dev/full rw

/proc/sys/kernel/version r
/proc/sys/kernel/ngroups_max r

/proc/meminfo r
/proc/stat r
/proc/cpuinfo r
/sys/devices/system/cpu/online r

/proc/filesystems r

** shm

/dev/shm rwcd

** tmp

/tmp rwcd
/var/tmp rwcd

** auth

/etc/pam.d r
/etc/security r
/etc/shadow r

** audio

/dev/snd/* rw
/proc/asound rw

# PulseAudio
/etc/pulse r
/home/*/.config/pulse rwcd
/run/user/*/pulse rwcd

** console

# Always refers to the controlling terminal
/dev/tty rw
/dev/console rw

# Risky: allows access to all terminals
/dev/pts rw

** private

/home/*/.*history h

/home/*/.viminfo h
/home/*/.vimrc h

/home/*/.zshrc h
/home/*/.zshenv h
/home/*/.zlogin h
/home/*/.zlogout h

/home/*/.gnupg h
/home/*/.ssh h

** user/gnupg

/home/*/.gnupg r

** user/ssh

/home/*/.ssh r

** user/zsh

/home/*/.*zwc rwcd
/home/*/.zcompdump rwcd
/home/*/.zlogin r
/home/*/.zlogout r
/home/*/.zsh_history rw
/home/*/.zshenv r
/home/*/.zshrc r

* Achieving store privacy

** Method A

All paths explicit

Pro: true privacy
Con: too much effort

** Method B

No enumeration, only known paths

#+BEGIN_EXAMPLE
/nix/store h
/nix/store/* rx # */
#+END_EXAMPLE

Pro: close to true privacy
Pro: little effort
Con: confuses tools that expect the top of the tree to exist
(to wit, it makes no sense that /nix/store/foo exists whereas
/nix/store does not).

** Method C

#+BEGIN_EXAMPLE
/nix/store
/nix/store/*/lib/*.so* rx
/nix/store/*/bin/* x
/nix/store/*/etc r
/nix/store/*/share r
#+END_EXAMPLE

Here we assume that subjects add specific paths to the policy
(e.g., for keys and such)

Con: assumes that none of the readable paths /etc, /share
contain sensitive data; a process can easily enumerate the
Store, looking for interesting information.

** Summary

Method B offers the best compromise between privacy and
effort, though it may break some tools.
